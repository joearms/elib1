%% Copyright (c) 2006-2009 Joe Armstrong
%% See MIT-LICENSE for licensing information.

-module(elib1_publish).
-compile(export_all).
-import(lists, [reverse/1]).

%% run elib1_rsa:make_sig("joe").
%% publish:publish()
%% c(nmap)
%% publish:validate()


compile() ->
    L = filelib:wildcard("*.erl"),
    [compile_file(I) || I <- L].

test() ->
    compile_file("elib1_rsa.erl").

compile_file(File) ->
    {ok, Mod, Bin} = compile:file(File, [no_error_module_mismatch,
					 binary,{parse_transform, ?MODULE}]),
    OF = atom_to_list(Mod) ++ ".beam",
    io:format("creating:~p~n",[OF]),
    file:write_file(OF, Bin).

parse_transform(X, Opts) ->
    elib1_misc:dump("foo", {X,Opts}),
    Y = xform(X),
    elib1_misc:dump("bar", Y),
    Y.

xform({attribute,Ln,module,Mod}) ->
    {attribute,Ln,module,rename(Mod)};
%% Is this a bug or a feature?
xform({attribute,Ln,import,{Mod,L}}) ->
    {attribute,Ln,import, {rename(Mod), L}};
xform({call,Ln,{remote,Ln1,{atom,Ln2,       Mod }, Func},       Args }) ->
    {call, Ln, {remote,Ln1,{atom,Ln2,rename(Mod)}, Func}, xform(Args)};
xform(T) when is_tuple(T) ->
    %% io:format("T=~p~n",[T]),
    L = tuple_to_list(T),
    L1 = [xform(I) || I <- L],
    list_to_tuple(L1);
xform([H|T]) ->
    [xform(H)|xform(T)];
xform(X) ->
    X.

rename(Mod) ->
    Data = nmap:map(),
    case lists:keysearch(Mod,1,Data) of
	{value, Tuple} ->
	    New = element(4, Tuple),
	    %% io:format("Rename:~p -> ~w~n",[Mod,New]),
	    New;
	false ->
	    Mod
    end.


publish() ->
    elib1_misc:show_loaded(fun() ->
				   publish1()
			   end).
publish1() ->
    Key = find_key(),
    L = filelib:wildcard("*.erl"),
    Data = [process(I,Key) || I <- L],
    {ok, S} = file:open("nmap.erl", [write]),
    io:format(S,"-module(nmap).~n",[]),
    io:format(S,"%% autogenerated do not edit by hand.~n",[]),
    io:format(S,"-export([map/0]).~n",[]),
    io:format(S,"map()->~n~p.~n",[Data]),
    file:close(S),
    ok.

validate() ->
    Expected = nmap:map(),
    case check(Expected, []) of
	[] ->
	    ok;
	L ->
	    {failed, L}
    end.

check([{Mod,File,Key,NewModName,Sign}|T], L) ->
    io:format("checking:~s ",[File]),
    [$m|M] = atom_to_list(NewModName),
    Md5= elib1_misc:hex2bin(M),
    case file:read_file(File) of
	{ok, B} ->
	    case erlang:md5(B) of
		Md5 ->
		    io:format("md5 ok"),
		    case file:read_file(Key++".pub") of
			{ok, Bin} ->
			    Code = binary_to_term(Bin),
			    case elib1_rsa:decode_sig(Sign , Code) of
				Md5 ->
				    io:format(" signed~n"),
				    check(T, L);
				_ ->
				    io:format(" bad sig~n"),
				    check(T, [File|L])
			    end;
			_ ->
			    io:format("no keyfile~n"),
			    check(T, [File|L])
		    end;
		_ ->
		    io:format("bad checksum~n"),
		    check(T, [File|L])
	    end;
	_  ->
	    io:format(" enreadable~n"),
	    check(T, [File|L])
    end;
check([], L) ->
    L.

find_key() ->
    case filelib:wildcard("*.pri") of
	[X] ->
	    Key = elib1_rsa:get_key(X),
	    "irp." ++ X1 = reverse(X),
	    Who = reverse(X1),
	    {Who, Key};
	[] ->
	    exit(eNoKey);
	O ->
	    exit({badKeys,O})
    end.

process(File,{Who,Key}) ->
    {ok, Bin} = file:read_file(File),
    Md5Bin = erlang:md5(Bin),
    Sig = elib1_rsa:sign_bin(Md5Bin, Key),
    Mod = list_to_atom(filename:rootname(File)),
    NewName = list_to_atom("m" ++ elib1_misc:bin2hex(Md5Bin)),
    {Mod,File,Who,NewName,Sig}.

